<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xv6源码阅读</title>
    <link href="/2022/09/04/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <url>/2022/09/04/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="使用gdb远程调试xv6"><a href="#使用gdb远程调试xv6" class="headerlink" title="使用gdb远程调试xv6"></a>使用gdb远程调试xv6</h2><p>在终端1运行xv6:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd xv6-riscv<br>make qemu-gdb<br></code></pre></td></tr></table></figure><p>在终端2输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd xv6 xv6-riscv<br>gdb-multiarch  kernel/kernel<br>target remote localhost:26000<br></code></pre></td></tr></table></figure><p>此时终端1显示程序运行结果，终端2是调试界面。</p><h2 id="xv6初始化"><a href="#xv6初始化" class="headerlink" title="xv6初始化"></a>xv6初始化</h2><p>从内核第一条指令开始调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在内核第一条指令处打断点</span><br>b _entry<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行到断点处停止</span><br>c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看接下来的十条指令</span><br>x /10i $pc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">单步调试</span><br>si<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看地址0x80000000处的指令</span><br>x 0x80000000<br></code></pre></td></tr></table></figure><p>此时CPU处于机器模式。内核做的第一件事情是，为C语言设置了栈空间。<br><code>stack0</code>就是为所有CPU分配的栈空间，每个CPU的栈空间大小为4K。对于一个特定的核，把<code>栈顶</code>指针加载到栈指针寄存器<code>sp</code>中，C语言就可以将其作为栈使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">la sp, stack0<br>li a0, 1024*4<br>csrr a1, mhartid<br># 因为要得到的是栈顶指针，所以加1<br>addi a1, a1, 1<br>mul a0, a0, a1<br>add sp, sp, a0  <br></code></pre></td></tr></table></figure><p>栈空间如下图所示：<br><img src="/./xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/tmpB29E.png" alt="栈空间图示"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6实验笔记</title>
    <link href="/2022/09/02/xv6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/02/xv6%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="utilities"><a href="#utilities" class="headerlink" title="utilities"></a>utilities</h2><h3 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h3><p>为什么建议使用两个管道呢？<br>如下，只是用一个管道实现父子进程之间的双向通信。父进程向管道中写入<code>&quot;ping&quot;</code>之后关闭管道的写入端，子进程从管道中读取到<code>&quot;ping&quot;</code>后向管道中写入<code>&quot;pong&quot;</code>之后关闭管道的写入端，父进程从管道中读取到<code>&quot;pong&quot;</code>，似乎完成了任务。</p><p>但是这里犯了一个经典的错误，假设了操作系统对多个进程的调度顺序。考虑这样一种情况，在子进程从管道中读取到<code>&quot;ping&quot;</code>之前，父进程从管道中读取到了<code>&quot;ping&quot;</code>，这是完全有可能的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fork())<br>    &#123;<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br>        close(p[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">5</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">5</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>复习C语言的标准库函数和指针使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//strcmp比较两个字符串，两个参数分别是字符串起始位置的指针</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(filename), filename) == <span class="hljs-number">0</span>)<br><span class="hljs-comment">//因为要扩充path字符串，为了避免溢出，分配了一个更长的字符串buf,把path拷贝到buf</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br><span class="hljs-built_in">strcpy</span>(buf, path);<br>p = buf + <span class="hljs-built_in">strlen</span>(buf);<br><span class="hljs-comment">// *p++ 先取指针p指向的值（数组第一个元素1），再将指针p自增1；</span><br><span class="hljs-comment">//（* 和++ （单目运算）两个处于同一优先级,结合方向是自右向左</span><br><span class="hljs-comment">//但是前提是当++在变量前面的时候才处理同一优先级,当++在变量之后时,可以将++的优先级看成最低级的</span><br>*p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>&#123;<br><span class="hljs-comment">//inum的值为0的是已删除目录项。这种标记的方式使文件删除更快</span><br><span class="hljs-comment">//如FAT32的已删除目录项第一个字节是0xE5</span><br>    <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">//从de.name到p拷贝DIRSIZ个字符，</span><br>    memmove(p, de.name, DIRSIZ);<br>    p[DIRSIZ] = <span class="hljs-number">0</span>;<br>    find(buf, filename);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>这里我用了比较多的指针操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> *argv_n[MAXARG];<br><span class="hljs-type">char</span> **p = argv_n;<br><span class="hljs-comment">//复制字符串数组时使用了指针遍历数组而不是索引，然后在新数组中追加字符串时使用*(p++)</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>&#123;<br>    *p++ = argv[i];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="system-calls"><a href="#system-calls" class="headerlink" title="system calls"></a>system calls</h2><h3 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h3><p>trace的参数为一个二进制掩码。如下，32为2^5，所以这里跟踪的是5号系统调用。会打印出运行grep时，进程和过程中创建的子进程的进程号，系统调用名和返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">trace <span class="hljs-number">32</span> grep hello README<br></code></pre></td></tr></table></figure><p>打印系统调用信息的行为不是在<code>trace</code>系统调用中发生的，<code>trace</code>只是修改了PCB中的<code>mask</code>值，<code>syscall</code>在返回前会通过<code>mask</code>判断是否需要打印信息。</p><p>内核代码不再使用用户进程的页表，无法通过用户态传递的虚拟地址访问物理内存，所以不能通过C语言传递系统调用的参数。需要使用<code>argraw()</code>从相应寄存器中获取系统调用的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint64<br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h3><p><code>sysinfo</code>接收一个<code>sysinfo</code>结构体的指针，然后把系统的信息写入这个结构体。</p><p><code>kalloc.c</code>中的结构体<code>kmem</code>中有一个<code>freelist</code>链表，储存了空闲页组成的链表。</p><p><code>proc.c</code>中的结构体<code>proc</code>记录了一个进程的状态，一个同名的数组<code>proc</code>记录了所有的<code>proc</code>，遍历这个数组，获得可用的进程数目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;data, <span class="hljs-keyword">sizeof</span>(data)); <span class="hljs-comment">// 将内核态的 data 变量（常为struct），结合进程的页表，写到进程内存空间内的 addr 地址处。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来用C++写一个哈希表吧!</title>
    <link href="/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%A7/"/>
    <url>/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>前天写了<a href="http://web.stanford.edu/class/cs106l/">CS106L 2022 SPRING</a>的Assignment3，记录一下自己的收获。</p><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>先分配一个长度和<code>other</code>相同的<code>_buckets_array</code>，然后拷贝<code>other._buckets_array</code>中的每一个链表。需要注意的地方是避免解引用空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(<span class="hljs-type">const</span> HashMap &amp;other) : _size&#123;other._size&#125;,<br>                                                  _hash_function&#123;other._hash_function&#125;,<br>                                                  _buckets_array(other._buckets_array.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">nullptr</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; other._buckets_array.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        node *other_node = other._buckets_array[i];<br>        <span class="hljs-keyword">if</span> (other_node == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _buckets_array[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _buckets_array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(other_node-&gt;value, <span class="hljs-literal">nullptr</span>);<br>            node *curr_node = _buckets_array[i]; <br>            <span class="hljs-keyword">while</span> (other_node-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                other_node = other_node-&gt;next;<br>                curr_node-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(other_node-&gt;value, <span class="hljs-literal">nullptr</span>);<br>                curr_node = curr_node-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(HashMap &amp;&amp;other) : _size&#123;other._size&#125;<br>&#123;<br>    _hash_function = std::<span class="hljs-built_in">move</span>(other._hash_function);<br>    _buckets_array = std::<span class="hljs-built_in">move</span>(other._buckets_array);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><p> 首先判断是否是自我赋值，然后调用<code>clear()</code>释放<code>_buckets_array</code>中原有的链表的内存，调用<code>insert()</code>插入新的元素。这里我犯了一个思维定式的错误，盲目把<code>other</code>的所有成员拷贝过来，但是这里<code>_size</code>在<code>insert()</code>和clear&#96;中是自动维护的。</p><p>使用range-based for loop时，如果获取引用而不是值，<code>auto &amp;&amp;value</code>这种写法是最佳实践，这里<code>&amp;&amp;</code>是万能引用，可以自动匹配<code>&amp;</code>,<code>const &amp;</code>或<code>&amp;&amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt; &amp;HashMap&lt;K, M, H&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HashMap&lt;K, M, H&gt; &amp;other)<br>&#123;<br>    <span class="hljs-comment">//比较地址，判断是否是自我赋值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// _size = other._size;</span><br>    _hash_function = other._hash_function;<br>    <span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;value : other)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动赋值"><a href="#移动赋值" class="headerlink" title="移动赋值"></a>移动赋值</h2><p>同样，首先判断是否是自我赋值，然后move每一个成员。</p><h3 id="边界测试"><a href="#边界测试" class="headerlink" title="边界测试"></a>边界测试</h3><p>这里涉及很多有趣的细节，请教了身边的C++高手，收获颇丰。测试代码中有这样一行，这一行发生了什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map1 = std::<span class="hljs-built_in">move</span>(map2) = std::<span class="hljs-built_in">move</span>(map2) = std::<span class="hljs-built_in">move</span>(map1);<br></code></pre></td></tr></table></figure><p>赋值符号是右结合的，所以先进行的运算是<code>std::move(map2) = std::move(map1)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> <span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward _Arg as movable</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::move(map2)</code>返回了<code>map2</code>的右值引用。对返回值调用<code>=</code>运算符，这时调用了<code>map2</code>的移动赋值函数，我实现的移动赋值函数的返回值是<code>&amp;HashMap</code>类型，所以下一个赋值运算符调用的是拷贝赋值函数！</p><p>还有一个细节，这里在map1移动之后，仍然使用了<code>map1</code>，这不是好的用法，但是C++并没有限制我们这样做。我在<code>gcc version 7.5.0</code>环境下测试，STL中的<code>vector</code>和<code>unordered_map</code>的对象在被移动后，会留下一个空的可以使用的容器。开始我使用移动赋值，把<code>other</code>的<code>_buckets_array</code>的数据转移到了<code>this</code>中，但是这给<code>other</code>留下了一个空的<code>_buckets_array</code>，对于本次设计的<code>HashMap</code>来说，总是假设<code>_buckets_array</code>非空，移动之后的<code>HashMap</code>并不是一个可用的容器。所以这里使用了<code>swap</code>函数实现了<code>_buckets_array</code>的移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt; &amp;HashMap&lt;K, M, H&gt;::<span class="hljs-keyword">operator</span>=(HashMap&lt;K, M, H&gt; &amp;&amp;other)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-built_in">clear</span>();<br>    _size = std::<span class="hljs-built_in">move</span>(other._size);<br>    <span class="hljs-comment">//不要混淆_size和_buckets_array.size()</span><br>    other._size = <span class="hljs-number">0</span>;<br>    _hash_function = std::<span class="hljs-built_in">move</span>(other._hash_function);<br>    _buckets_array.<span class="hljs-built_in">swap</span>(other._buckets_array);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const接口的实现"><a href="#const接口的实现" class="headerlink" title="const接口的实现"></a>const接口的实现</h2><p>使用模板生成了<code>iterator</code>和<code>const_iterator</code>两套代码。基础设施写好后，在编写迭代器时，完全不需要考虑返回的是const值还是非const值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst = <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">class</span> HashMapIterator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = std::<span class="hljs-type">conditional_t</span>&lt;IsConst, <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> Map::value_type, <span class="hljs-keyword">typename</span> Map::value_type&gt;;<br><br>    <span class="hljs-keyword">using</span> pointer = value_type *;<br>    <span class="hljs-keyword">using</span> reference = value_type &amp;;<br><br>    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;<br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br>HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-built_in">HashMapIterator</span>(bucket_array_type *buckets_array, node *node,<br>                                               <span class="hljs-type">size_t</span> bucket) : _buckets_array(buckets_array),<br>                                                                _node(node),<br>                                                                _bucket(bucket) &#123;&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::reference HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _node-&gt;value; <span class="hljs-comment">// _node can&#x27;t be nullptr - that would be dereferencing end()</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::pointer HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> &amp;(_node-&gt;value); <span class="hljs-comment">// _node can&#x27;t be nullptr - that would be dereferencing end()</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H = std::hash&lt;K&gt;&gt;<br><span class="hljs-keyword">class</span> HashMap<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> iterator = HashMapIterator&lt;HashMap, <span class="hljs-literal">false</span>&gt;;<br>    <span class="hljs-keyword">using</span> const_iterator = HashMapIterator&lt;HashMap, <span class="hljs-literal">true</span>&gt;;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-type">const</span></span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> K &amp;key)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_iterator</span>(<span class="hljs-built_in">find_node</span>(key).second);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::const_iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> K &amp;key) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">// This is called the static_cast/const_cast trick, which allows us to reuse</span><br>    <span class="hljs-comment">// the non-const version of find to implement the const version.</span><br>    <span class="hljs-comment">// The idea is to cast this so it&#x27;s pointing to a non-const HashMap, which</span><br>    <span class="hljs-comment">// calls the overload above (and prevent infinite recursion).</span><br>    <span class="hljs-comment">// Also note that we are calling the conversion operator in the iterator class!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;const_iterator&gt;(<span class="hljs-keyword">const_cast</span>&lt;HashMap&lt;K, M, H&gt; *&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">find</span>(key));<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">make_iterator</span>(node *curr)<br>&#123;<br>    <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> &#123;&amp;_buckets_array, curr, <span class="hljs-built_in">bucket_count</span>()&#125;;<br>    &#125;<br>    <span class="hljs-type">size_t</span> index = _hash_function(curr-&gt;value.first) % <span class="hljs-built_in">bucket_count</span>();<br>    <span class="hljs-keyword">return</span> &#123;&amp;_buckets_array, curr, index&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，测试程序存在问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HashMap&lt;std::string, <span class="hljs-type">int</span>&gt; copy = map1;<br>        HashMap&lt;std::string, <span class="hljs-type">int</span>&gt; temp, new_assign;<br>        temp = std::<span class="hljs-built_in">move</span>(map1);<br>        new_assign = std::<span class="hljs-built_in">move</span>(temp);<br>        <span class="hljs-built_in">VERIFY_TRUE</span>(<span class="hljs-built_in">check_map_equal</span>(new_assign, temp), __LINE__);<br></code></pre></td></tr></table></figure><p><code>new_assign</code>和<code>temp</code>是不会<code>equal</code>的，应该把最后一行的<code>temp</code>改为<code>copy</code>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来用C++写一个字典树吧!</title>
    <link href="/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E6%A0%91%E5%90%A7/"/>
    <url>/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E6%A0%91%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>今天写了<a href="https://15445.courses.cs.cmu.edu/fall2022/">CMU15-445 2022 FALL</a>的Project0，记录一下自己的收获。</p><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>这个project的内容是用C++实现一个字典树。字典树需要频繁地对节点的子节点进行查找，插入和删除。unordered_map的底层实现是哈希表，所以查找、插入和删除的平均时间复杂度都是O(1)，在这个project中非常合适。</p><p>我对标准库提供的API还不熟悉，在这里记录一下自己今天的写法,以便日后复习和改正。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//根据指定的key查找对应的value</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-comment">//这里值得注意的是如果key不存在，会自动插入一个默认值，所以先处理了key不存在的情况。</span><br><span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br><br><span class="hljs-comment">//查找unorder_map中是否存在指定的key，和上面的count实现的是相同的功能。</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">find</span>(key_char) != <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-comment">//判断是否为空</span><br><span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">empty</span>();<br><br><span class="hljs-comment">//删除指定的key</span><br><span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">erase</span>(key_char);<br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>子类想要调用父类的构造函数，只能写在参数初始化列表里面。</li><li>非基本类型尽量在参数列表中赋值，写的时候总是忘记。</li></ol><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在插入节点时使用了移动语义</span><br><span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, std::unique_ptr&lt;TrieNode&gt; &amp;&amp;child)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) != <span class="hljs-number">0</span> || child-&gt;<span class="hljs-built_in">GetKeyChar</span>() != key_char) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;children_[key_char] = std::<span class="hljs-built_in">move</span>(child);<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br>matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br><br><span class="hljs-comment">//试图获得一个节点时，得到的总是一个unique_ptr的指针，不获取所有权</span><br><span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="字典树的基本操作实现"><a href="#字典树的基本操作实现" class="headerlink" title="字典树的基本操作实现"></a>字典树的基本操作实现</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>遍历key，如果当前节点的子节点中没有key[i]，则插入一个新的节点，否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点的is_end_为true,则插入失败；否则插入成功，将当前节点的is_end_置为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, T value)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]) == <span class="hljs-literal">nullptr</span>) &#123;<br>        matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br>      &#125;<br>      <span class="hljs-keyword">auto</span> father_node = matched_node;<br>      matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里调用了TrieNodeWithValue的移动构造函数，将原来不含value的节点转换成了一个含有value的节点</span><br>        <span class="hljs-comment">//然后使用新节点替换了原来的节点</span><br>        <span class="hljs-keyword">auto</span> new_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(std::<span class="hljs-built_in">move</span>(**matched_node), value);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key[i]);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">move</span>(new_node));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>遍历key，使用一个栈保存遍历的路径。如果当前节点的子节点中没有key[i]，则删除失败；否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点的is_end_为false,则删除失败；否则删除成功，把is_end置为true。如果这个节点有子节点，删除结束。如果这个节点没有子节点，需要删除这个节点。然后回溯栈，删除没有子节点且没有值得节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">auto</span> node_stack = std::stack&lt;std::unique_ptr&lt;TrieNode&gt; *&gt;();<br>  <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>    <span class="hljs-type">char</span> key_char = key[i];<br>    <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    node_stack.<span class="hljs-built_in">push</span>(matched_node);<br>    matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char);<br>    <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key_char);<br>      <span class="hljs-keyword">while</span> (node_stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">auto</span> node = node_stack.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>() || node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        node_stack.<span class="hljs-built_in">pop</span>();<br>        node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetKeyChar</span>());<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>遍历key，如果当前节点的子节点中没有key[i]，查找失败，否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点没有值或者值的类型和查找的值的类型不匹配，查找失败，否则查找成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">bool</span> *success)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> cur_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-type">char</span> cur_char = key[i];<br>      <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      cur_node = cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-comment">//使用dynamic_cast检查节点含有的值的类型和要查找的值的类型是否相同。</span><br>          <span class="hljs-keyword">auto</span> tmp_node = <span class="hljs-keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur_node-&gt;<span class="hljs-built_in">get</span>());<br>          <span class="hljs-keyword">if</span> (tmp_node != <span class="hljs-literal">nullptr</span>) &#123;<br>            *success = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> tmp_node-&gt;<span class="hljs-built_in">GetValue</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    *success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> : key_char_(key_char) &#123;</span>&#125;<br>    <span class="hljs-built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="hljs-keyword">noexcept</span><br>    &#123;<br>        key_char_ = other_trie_node.key_char_;<br>        is_end_ = other_trie_node.is_end_;<br>        children_ = std::<span class="hljs-built_in">move</span>(other_trie_node.children_);<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TrieNode</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasChild</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">find</span>(key_char) != <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">end</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasChildren</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">empty</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEndNode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;is_end_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">GetKeyChar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> key_char_; &#125;<br>    std::unordered_map&lt;<span class="hljs-type">char</span>, std::unique_ptr&lt;TrieNode&gt;&gt; &amp;<span class="hljs-built_in">GetChildren</span>() &#123; <span class="hljs-keyword">return</span> children_; &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, std::unique_ptr&lt;TrieNode&gt; &amp;&amp;child)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) != <span class="hljs-number">0</span> || child-&gt;<span class="hljs-built_in">GetKeyChar</span>() != key_char)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;children_[key_char] = std::<span class="hljs-built_in">move</span>(child);<br>        <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">erase</span>(key_char);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEndNode</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_end)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;is_end_ = is_end; &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">char</span> key_char_;<br>    <span class="hljs-type">bool</span> is_end_&#123;<span class="hljs-literal">false</span>&#125;;<br>    std::unordered_map&lt;<span class="hljs-type">char</span>, std::unique_ptr&lt;TrieNode&gt;&gt; children_;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNodeWithValue</span> : <span class="hljs-keyword">public</span> TrieNode<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T value_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value) : <span class="hljs-built_in">TrieNode</span>(std::<span class="hljs-built_in">move</span>(trieNode))<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;value_ = value;<br>        <span class="hljs-keyword">this</span>-&gt;is_end_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">TrieNodeWithValue</span>(<span class="hljs-type">char</span> key_char, T value) : <span class="hljs-built_in">TrieNode</span>(key_char)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;value_ = value;<br>        <span class="hljs-keyword">this</span>-&gt;is_end_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">TrieNodeWithValue</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;TrieNode&gt; root_;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123; <span class="hljs-keyword">this</span>-&gt;root_ = std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(<span class="hljs-string">&#x27;\0&#x27;</span>); &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, T value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (key.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]) == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br>            &#125;<br>            <span class="hljs-keyword">auto</span> father_node = matched_node;<br>            matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]);<br>            <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>())<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">auto</span> tmp_node = std::<span class="hljs-built_in">move</span>(*matched_node);<br>                father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key[i]);<br>                <span class="hljs-keyword">auto</span> new_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(std::<span class="hljs-built_in">move</span>(*tmp_node), value);<br>                father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">move</span>(new_node));<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> node_stack = std::stack&lt;std::unique_ptr&lt;TrieNode&gt; *&gt;();<br>        <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++)<br>        &#123;<br>            <span class="hljs-type">char</span> key_char = key[i];<br>            <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char) == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node_stack.<span class="hljs-built_in">push</span>(matched_node);<br>            matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char);<br>            <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>())<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>())<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key_char);<br>                <span class="hljs-keyword">while</span> (node_stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">auto</span> node = node_stack.<span class="hljs-built_in">top</span>();<br>                    <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>() || node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>())<br>                    &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    node_stack.<span class="hljs-built_in">pop</span>();<br>                    node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetKeyChar</span>());<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">bool</span> *success)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>        <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++)<br>        &#123;<br>            <span class="hljs-type">char</span> cur_char = key[i];<br>            <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char) == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cur_node = cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char);<br>            <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>())<br>                &#123;<br>                    <span class="hljs-keyword">auto</span> tmp_node = <span class="hljs-keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur_node-&gt;<span class="hljs-built_in">get</span>());<br>                    <span class="hljs-keyword">if</span> (tmp_node != <span class="hljs-literal">nullptr</span>)<br>                    &#123;<br>                        *success = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">return</span> tmp_node-&gt;<span class="hljs-built_in">GetValue</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        *success = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
