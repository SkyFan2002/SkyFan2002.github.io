<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Extendible Hash Table</title>
    <link href="/2022/09/20/Extendible-Hash-Table/"/>
    <url>/2022/09/20/Extendible-Hash-Table/</url>
    
    <content type="html"><![CDATA[<p>对于一种Hash Table的内存布局，我们通常关注两个问题：如何处理冲突，如何动态扩展。</p><p>Extendible Hash Table把哈希值后缀相同的<code>key</code>存储在同一个bucket中，当一个bucket装满后，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tree indexes</title>
    <link href="/2022/09/19/Tree-indexes/"/>
    <url>/2022/09/19/Tree-indexes/</url>
    
    <content type="html"><![CDATA[<p>这是我阅读<a href="https://15445.courses.cs.cmu.edu/fall2021/schedule.html">CMU15445 2021 FALL</a>的Lecture 7的Slides的笔记。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>B+树是一种自平衡的树数据结构。B+树允许O(log n)的查找，插入和删除效率。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol><li>B+树是完美平衡的，每个叶子节点的深度都相同。</li><li>除了根节点之外的每个节点都至少是half-full的，即<code>M/2-1 ≤ #keys ≤ M-1</code>。</li><li>每个有k个key的内部节点有<code>k + 1</code>个非空的孩子节点。</li></ol><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>B+树的每个节点包含一个键值对的数组。这些键来源于索引所基于的属性。内部节点和叶子节点储存的值为不同类型。数组通常是相对于<code>key</code>有序的。</p><h5 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h5><p><img src="/2022/09/19/Tree-indexes/tmp8EEC.png" alt="Leaf Node"><br>sortd keys 排列在一块儿。因为 scan 的时候，只是检查 key。另外 key 的数据类型大小一致，　values 大小很可能不一致，如字符串。</p><h3 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a>B树 VS B+树</h3><p>B树和B+树的主要区别就在于B树的key不允许重复而且数据可以存储在任何结点，而B+树中的key可以重复，但是数据只能存储在叶子结点中。实际上B树的性能是高于B+树的，但是却很少得到使用，这是因为B+树在多线程下的表现好于B树。B+树的<code>key</code>信息只在<code>leaf node</code>中，更改信息以后只需要向上走，因此只需要 latch 一个向上的方向。但是 B Tree 需要 latch 两个方向，即向上和向下。</p><h3 id="Selection-Conditions"><a href="#Selection-Conditions" class="headerlink" title="Selection Conditions"></a>Selection Conditions</h3><p>这是B+树由于哈希表的地方。可以搜索<code>key</code>的一部分。<br><img src="/2022/09/19/Tree-indexes/tmp8102.png" alt="完整的key"><br><img src="/2022/09/19/Tree-indexes/tmp44E0.png" alt="部分的key"></p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>找到正确的叶子节点L。如果L中有足够的空间，直接插入到L中合适的位置，保证顺序即可；否则，分裂L为L和L2,平分L中原有的条目，复制middle key。把middle key和L2插入到L的父节点中。</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>找到正确的叶子节点L。删除要删除的条目。如果删除后L只有M&#x2F;2 - 1个条目，尝试从sibling借entry，如果没有借到，把L和sibling合并，合并后要注意从父节点中删除指向被合并节点的指针。</p><h3 id="重复的key"><a href="#重复的key" class="headerlink" title="重复的key"></a>重复的key</h3><h4 id="Append-Record-ID"><a href="#Append-Record-ID" class="headerlink" title="Append Record ID"></a>Append Record ID</h4><p>使用Record ID扩展<code>key</code>，保证<code>key</code>的唯一性。仍然可以使用原有的<code>key</code>寻找记录，在叶子节点再使用扩展后的<code>key</code>区分<code>key</code>相同的记录。<br><img src="/2022/09/19/Tree-indexes/tmp9DBA.png" alt="Append Record ID"></p><h4 id="Overflow-Leaf-Nodes"><a href="#Overflow-Leaf-Nodes" class="headerlink" title="Overflow Leaf Nodes"></a>Overflow Leaf Nodes</h4><p>允许叶子节点溢出为含有重复<code>key</code>的节点，这种实现更加难以维护。<br><img src="/2022/09/19/Tree-indexes/tmp7361.png" alt="Overflow leaf nodes"></p><h3 id="Clustered-indexes"><a href="#Clustered-indexes" class="headerlink" title="Clustered indexes"></a>Clustered indexes</h3><p>聚集索引。指页面在硬盘存储的顺序和索引中排序的顺序一致，即也被排序，而并非任意顺序。这种 Clustered Indexes 在对于 range query 很有帮助，顺序存取比随机存取快的多。</p><h3 id="B-树设计细节"><a href="#B-树设计细节" class="headerlink" title="B+树设计细节"></a>B+树设计细节</h3><h4 id="Node-Size"><a href="#Node-Size" class="headerlink" title="Node Size"></a>Node Size</h4><ol><li>存储设备。存储设备的速度越慢，建议使用更大的node size，以减少IO的次数。</li><li>工作负载。不同负载的optimal size不同。leaf node scan。root-to-leaf traversal。</li></ol><h4 id="Merge-Threshold（合并的阈值）"><a href="#Merge-Threshold（合并的阈值）" class="headerlink" title="Merge Threshold（合并的阈值）"></a>Merge Threshold（合并的阈值）</h4><p>如果一个 node 中元素少于 M&#x2F;2 - 1，即没有 half-full, 发生 underflow。我们可以让这个 node 故意保留存在，而不去 merge 它。然后每一段时间，批量处理 B+ tree 中所有这类的 node。</p><p>推迟合并操作可能降低重新组织的开销。</p><h4 id="Variable-Length-Keys"><a href="#Variable-Length-Keys" class="headerlink" title="Variable-Length Keys"></a>Variable-Length Keys</h4><h5 id="存key的指针"><a href="#存key的指针" class="headerlink" title="存key的指针"></a>存key的指针</h5><p>间接寻址太慢，很少用</p><h5 id="Variable-Length-Nodes"><a href="#Variable-Length-Nodes" class="headerlink" title="Variable Length Nodes"></a>Variable Length Nodes</h5><p>每个节点的大小可能不同。需要很小心的内存管理。不适合fix size page。同样很少使用。</p><h5 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h5><p>使用最长的那个key length。太浪费空间。</p><h5 id="Key-Map"><a href="#Key-Map" class="headerlink" title="Key Map"></a>Key Map</h5><p>在节点内嵌入一个指针的数组，指针指向节点内的kv list。最经常使用。</p><h4 id="Intra-Node-Search（节点内搜索）"><a href="#Intra-Node-Search（节点内搜索）" class="headerlink" title="Intra-Node Search（节点内搜索）"></a>Intra-Node Search（节点内搜索）</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hash Tables</title>
    <link href="/2022/09/16/Hash-Tables/"/>
    <url>/2022/09/16/Hash-Tables/</url>
    
    <content type="html"><![CDATA[<p>这是我阅读<a href="https://15445.courses.cs.cmu.edu/fall2021/schedule.html">CMU15445 2021 FALL</a>的Lecture 6的Slides的笔记。</p><h2 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h2><p>空间复杂度：O(n)</p><p>时间复杂度：</p><p>平均：O(1)  需要注意常数的大小！</p><p>最坏：O(n)</p><p>Hash Table的设计分为两个部分：</p><ol><li>Hash Functions<br>将<code>key</code>映射为一个Hash值。在DBMS中需要具有高性能和低冲突率的哈希函数。</li><li>Hash Schema<br>如何利用Hash值实现对value的插入，删除和查找操作。如果不存在冲突，我们完全可以用一个普通的数组实现hash表。但是在大多数情况下是存在冲突的，所以出现了不同的scheme以解决冲突。</li></ol><h2 id="Static-Hashing-Schemes"><a href="#Static-Hashing-Schemes" class="headerlink" title="Static Hashing Schemes"></a>Static Hashing Schemes</h2><p>static hash schemas下hash table的容量是固定的。如果容量不够，只能<code>resize</code>到更大的容量，<code>resize</code>操作需要<code>rehash</code>。这个操作对性能来说是灾难级别的。所以要一开始就选择合适的容量，避免<code>resize</code>。如何寻找合适的容量，我们可以进行 cardinality estimation。</p><h3 id="Liner-Probe-Hashing"><a href="#Liner-Probe-Hashing" class="headerlink" title="Liner Probe Hashing"></a>Liner Probe Hashing</h3><p>一个slot放一个value，通过线性地探测下一个空的slot来解决碰撞。简单但是性能差。</p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>线性探测的方法删除元素十分麻烦。在 hash join 中，我们只用 insert 和 find 这两个函数，而不用 delete。对于 hash join 这种操作<code>可以无视删除会导致的缺点</code>。但是在 index 索引中，insert, find, delete 这些操作都被需要。</p><h5 id="墓碑"><a href="#墓碑" class="headerlink" title="墓碑"></a>墓碑</h5><p><img src="/2022/09/16/Hash-Tables/tmpBC43.png" alt="Tombstone"></p><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p><img src="/2022/09/16/Hash-Tables/tmp5081.png" alt="Move"></p><h3 id="Non-Unique-Keys"><a href="#Non-Unique-Keys" class="headerlink" title="Non-Unique Keys"></a>Non-Unique Keys</h3><p>有两种处理重复 key 的方式:</p><ol><li>value list存储重复key所拥有的value</li><li>存储 key和value，这样即使key重复，value值也不一样。这种方式更加常见。</li></ol><h3 id="Robin-Hood-Hashing"><a href="#Robin-Hood-Hashing" class="headerlink" title="Robin Hood Hashing"></a>Robin Hood Hashing</h3><p>Robin Hood Hashing 和 Linear Probe Hashing 相比，更可以去平衡冲突，让冲突的 key 离它应该拥有的位置 (optimal position) 近一些。<code>正如它的名字一样</code>，罗宾汉，劫富济贫。<br>依然是线性地探测，但是每个<code>key</code>记录它离最佳位置的距离<code>distance</code>，<code>key</code> a在探测的时候不是简单地探测到<code>slot</code>被b占用就后移，而是比较<code>distance</code>，如果<code>a.instance &gt; b.instance</code>，则a占用这个slot，b被弹出后移。</p><p>Robin Hood在<code>insert</code>的时候会调整其他<code>key</code>的位置，需要更多写操作，在插入的时候需要更多条件检查，会造成更多分支预测miss。</p><p>实际实现上 Linear Probe Hashing 更为常见。</p><h3 id="Cuckoo-Hashing"><a href="#Cuckoo-Hashing" class="headerlink" title="Cuckoo Hashing"></a>Cuckoo Hashing</h3><p>使用多个哈希表，每个哈希表有自己的哈希函数。基于这样一个事实，对于两个key a和b，hash函数hash1和hash2。hash1(a) &#x3D; hash1(b)且hash2(a) &#x3D; hash2(b)的概率很小。</p><p>总向有空位置 (optimal position) 的 hash table 插入。如果所有的 hash table 都没有空位置可以插入。随机选择一个 hash table 中对应的位置插入，　并取出原来在这位置上的 key, 将它 insert 到其他的 hash table。</p><p>插入性能差，可能遇到连续的冲突。但是查询和删除性能为O(1)，因为只检查每个哈希表一次。</p><h2 id="Dynamic-Hashing-Schemes"><a href="#Dynamic-Hashing-Schemes" class="headerlink" title="Dynamic Hashing Schemes"></a>Dynamic Hashing Schemes</h2><p>我们主要关注两个方面：如何解决冲突，如何高效地动态扩展。</p><h3 id="Chained-Hashing"><a href="#Chained-Hashing" class="headerlink" title="Chained Hashing"></a>Chained Hashing</h3><p>slot里放链表。参考我这篇<a href="https://skyfan2002.github.io/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%A7/">博客</a>的实现。<br>链表不一定是单链表，ppt中的例子是块状链表：<br><img src="/2022/09/16/Hash-Tables/tmp3B10.png" alt="chained hashing"></p><h3 id="Extendible-Hashing"><a href="#Extendible-Hashing" class="headerlink" title="Extendible Hashing"></a>Extendible Hashing</h3><h4 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h4><p>Extendible Hashing通过把哈希值的前缀相同的<code>key</code>放入一个bucket解决冲突。</p><h4 id="如何动态扩展"><a href="#如何动态扩展" class="headerlink" title="如何动态扩展"></a>如何动态扩展</h4><p>如图，C的前缀是10，但是10对应的bucket已满，而且指向10的箭头只有一个，不可以直接分裂bucket。<br><img src="/2022/09/16/Hash-Tables/tmp1951.png" alt="to extend"><br>将目录（左侧的前缀索引）扩展一位，只需要把10对应的bucket拆分成两个Bucket，其他bucket只要把指针指过去就好了，自然扩展。</p><p>directory 是一个 array of pointer 或者 array of page id。用 latch 保护这个 array,　然后扩大它的容量，复制原来的内容进入以后，就可以解开 latch 了。这个过程不涉及 rehash 和大量的数据复制，因此很快速。<br><img src="/2022/09/16/Hash-Tables/tmp95EF.png" alt="extended"></p><h3 id="Linear-Hashing"><a href="#Linear-Hashing" class="headerlink" title="Linear Hashing"></a>Linear Hashing</h3><h4 id="如何解决冲突-1"><a href="#如何解决冲突-1" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h4><p>把哈希值mod数组长度n的值相同的<code>key</code>放入一个bucket解决冲突。</p><h4 id="如何动态扩展-1"><a href="#如何动态扩展-1" class="headerlink" title="如何动态扩展"></a>如何动态扩展</h4><p>当一个想要插入的Bucket已满的时候，顺序分裂一个bucket A，分裂得到的bucket放 B到directory（左侧的索引数组）末尾，原bucket A的数据mod <code>2n</code>后必然在A或B之中，顺序分裂一轮之后，扩展n的值为2n。<br><img src="/2022/09/16/Hash-Tables/tmp9B24.png" alt="Linear Hashing"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《C++并发编程实战》第二章：Managing threads</title>
    <link href="/2022/09/11/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AManaging-threads/"/>
    <url>/2022/09/11/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AManaging-threads/</url>
    
    <content type="html"><![CDATA[<h2 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程在<code>std::thread</code>对象创建时启动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_some_work</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(do_some_work)</span></span>;<br></code></pre></td></tr></table></figure><p>还可以传入函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">background_task</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-built_in">do_something</span>();<br> <span class="hljs-built_in">do_something_else</span>();<br> &#125;<br>&#125;;<br>background_task f;<br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(f)</span></span>;<br></code></pre></td></tr></table></figure><p>传入函数对象时有一个要注意的点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//传一个临时对象，会被编译器解释为声明了一个函数，而不是启动了一个线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">(background_task())</span></span>;<br><span class="hljs-comment">//可以这样写</span><br><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">((background_task()))</span></span>; <br>std::thread my_thread&#123;<span class="hljs-built_in">background_task</span>()&#125;;    <br></code></pre></td></tr></table></figure><p>还可以传入lambda表达式，lanbda是一个可以<code>捕获局部变量</code>的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::thread <span class="hljs-title">my_thread</span><span class="hljs-params">([]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  do_something();</span></span><br><span class="hljs-params"><span class="hljs-function">  do_something_else();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br></code></pre></td></tr></table></figure><p>在<code>std::thread</code>对象被销毁之前，必须调用<code>join()</code>或者<code>detach()</code>。这是标准库实现规定的，如果你不这样做，程序会被强行中止。</p><p>注意<code>std::thread</code>对象被销毁不意味着线程结束运行。</p><h3 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h3><p>等待线程完成,在<code>t</code>完成之前，<code>join()</code>会阻塞当前线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><h4 id="存在exception的情况"><a href="#存在exception的情况" class="headerlink" title="存在exception的情况"></a>存在exception的情况</h4><p>RAII，定义一个资源管理类，在类的析构函数中调用<code>join()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(my_func)</span></span>;<br> <span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<br> <span class="hljs-built_in">do_something_in_current_thread</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_guard</span><br>&#123;<br>    std::thread&amp; t;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(std::thread&amp; t_)</span>:</span><br><span class="hljs-function">    t(t_)&#123;</span>&#125;<br>    ~<span class="hljs-built_in">thread_guard</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>()) <br>        &#123;<br>            t.<span class="hljs-built_in">join</span>(); <br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//delete</span><br>    <span class="hljs-built_in">thread_guard</span>(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>; <br>    thread_guard&amp; <span class="hljs-keyword">operator</span>=(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在离开作用域时，对象的析构顺序是和构造顺序相反的。<code>thread_guard</code>首先析构，调用<code>thread</code>的<code>join()</code>，然后<code>thread</code>析构，不会中止程序。</p><h3 id="在后台运行线程"><a href="#在后台运行线程" class="headerlink" title="在后台运行线程"></a>在后台运行线程</h3><p>如果你不调用<code>join()</code>等待线程结束，你必须保证被这个线程访问的数据在线程结束前始终有效。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Buffer Pools</title>
    <link href="/2022/09/09/Buffer-Pools/"/>
    <url>/2022/09/09/Buffer-Pools/</url>
    
    <content type="html"><![CDATA[<p>这是我阅读<a href="https://15445.courses.cs.cmu.edu/fall2021/schedule.html">CMU15445 2021 FALL</a>的Lecture 5的Slides的笔记。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Page:磁盘上的一页数据。</p><p>Frame：一块内存。正好能容纳一页数据。</p><p>Buffer Pool:一个Frame组成的数组。</p><p>Locks:用于隔离事务的类似锁的结构。</p><p>Latches:我们常说的线程间的互斥锁。</p><p>page table:内存数据结构，记录page id到page在page在buffer pool中的位置的映射。维护一些Page的元数据，脏页标志，Pin&#x2F;Reference计数。</p><p>page directory:持久化存储到磁盘上。记录page id到page在磁盘上的位置的映射。</p><h2 id="Buffer-Pool优化"><a href="#Buffer-Pool优化" class="headerlink" title="Buffer Pool优化"></a>Buffer Pool优化</h2><h3 id="Multiple-Buffer-Pool"><a href="#Multiple-Buffer-Pool" class="headerlink" title="Multiple Buffer Pool"></a>Multiple Buffer Pool</h3><p>例如，每个数据库一个Buffer Pool,每种类型的页一个Buffer Pool。有利于降低锁的粒度，提高局部性。</p><h4 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h4><p>如何把Page分散到不同的Buffer Pool中呢？</p><ol><li>在Page ID中嵌入一个Buffer Pool ID</li><li>对Page ID哈希</li></ol><h3 id="Pre-fetching"><a href="#Pre-fetching" class="headerlink" title="Pre-fetching"></a>Pre-fetching</h3><p>根据执行计划推断可能要用到的页，提前把页加载到Buffer Pool中。</p><h4 id="Sequential-Scans"><a href="#Sequential-Scans" class="headerlink" title="Sequential Scans"></a>Sequential Scans</h4><p><img src="/2022/09/09/Buffer-Pools/tmpF0BD.png" alt="Sequential Scans PreFetching 1"><br><img src="/2022/09/09/Buffer-Pools/tmpE2F.png" alt="Sequential Scans PreFetching 2"></p><h4 id="Index-Scans"><a href="#Index-Scans" class="headerlink" title="Index Scans"></a>Index Scans</h4><p><img src="/2022/09/09/Buffer-Pools/tmpE0B9.png" alt="Index Scans PreFetching"></p><h3 id="Scan-Sharing"><a href="#Scan-Sharing" class="headerlink" title="Scan Sharing"></a>Scan Sharing</h3><p>不同的查询之间共享中间结果。比如<code>Scan</code>,<code>Join</code>等算子的结果。<br><img src="/2022/09/09/Buffer-Pools/../Buffer-Pools/tmp6F4.png" alt="Scan Sharing1"><br><img src="/2022/09/09/Buffer-Pools/../Buffer-Pools/tmp1330.png" alt="Scan Sharing2"></p><h3 id="绕过Buffer-Pool"><a href="#绕过Buffer-Pool" class="headerlink" title="绕过Buffer Pool"></a>绕过Buffer Pool</h3><p>sequantial scan 会将大部分 page 加载进 buffer pool, 而这些 page 又并不一定在未来会被重复利用。对这种 sequantial scan 的 Query，我们可以单独给 allocate 一块内存区域，而独立于且不影响 buffer pool。这一块专属的内存区域依然能保证对当前 Query 的性能，而且因为不会打乱污染 buffer pool 而影响其他 Query 的性能。这块内存区域会在该 sequantial scan Query 结束后被释放。</p><p>这里和文件分区的思想有共通之处。</p><h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h3><p>大多数数据库使用Direct IO绕过OS的Page Cache，减少数据的复制，不难理解。</p><h3 id="Buffer替换策略"><a href="#Buffer替换策略" class="headerlink" title="Buffer替换策略"></a>Buffer替换策略</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>为每一个page保存一个最近一次被访问的时间戳，当DBMS决定从Buffer Pool中逐出一个Page时，选择拥有最老的时间戳的page。</p><h4 id="CLOCK"><a href="#CLOCK" class="headerlink" title="CLOCK"></a>CLOCK</h4><p>一种不需要单独的时间戳，实现近似的LRU的算法。</p><p>每个page有一个比特位记录最近是否被访问，如果被访问过，比特位设置为1。</p><p>当需要替换一个页的时候，使用时钟指针循环遍历pages，如果一个page的比特位是1，把它设置为0，如果是0，替换这个比特位。<br><img src="/2022/09/09/Buffer-Pools/tmpF712.png" alt="CLOCK"></p><h4 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h4><p>LRU和CLOCK都对sequential flooding敏感。顺序扫描在Buffer Pool中加载了大量的未来不会被利用的页面，导致这样一种情况，最近被使用过的页面是不太可能被再次访问的。</p><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><p>记录每个页面最近K次被访问的时间戳。</p><h4 id="LOCALIZATION"><a href="#LOCALIZATION" class="headerlink" title="LOCALIZATION"></a>LOCALIZATION</h4><p>给每一个query一个独立的Buffer Pool，避免了不同的query之间相互污染。</p><h4 id="Priority-Hints"><a href="#Priority-Hints" class="headerlink" title="Priority Hints"></a>Priority Hints</h4><p>数据库可以根据查询执行的上下文提供给Buffer Pool一些提示，哪些页面比较重要，或不重要。</p><h4 id="Dirty-Pages"><a href="#Dirty-Pages" class="headerlink" title="Dirty Pages"></a>Dirty Pages</h4><p>Dirty Pages被替换出缓冲区后需要写回磁盘。如果每次等 eviction 的时候再去 flush 脏页，会让 eviction 的过程非常的慢。</p><p>所以数据库管理系统可以定期地遍历page table，把脏页写回磁盘，然后逐出脏页，或者把dirty flag设置为0。</p><p>在日志被写入磁盘前，不必写回脏页。</p><h3 id="数据库中其他的内存池"><a href="#数据库中其他的内存池" class="headerlink" title="数据库中其他的内存池"></a>数据库中其他的内存池</h3><p>→ Sorting + Join Buffers<br>→ Query Caches<br>→ Maintenance Buffers<br>→ Log Buffers<br>→ Dictionary Caches</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6 2021 lab1: utilities</title>
    <link href="/2022/09/09/xv6-2021-lab1-utilities/"/>
    <url>/2022/09/09/xv6-2021-lab1-utilities/</url>
    
    <content type="html"><![CDATA[<h3 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h3><p>为什么建议使用两个管道呢？<br>如下，只是用一个管道实现父子进程之间的双向通信。父进程向管道中写入<code>&quot;ping&quot;</code>之后关闭管道的写入端，子进程从管道中读取到<code>&quot;ping&quot;</code>后向管道中写入<code>&quot;pong&quot;</code>之后关闭管道的写入端，父进程从管道中读取到<code>&quot;pong&quot;</code>，似乎完成了任务。</p><p>但是这里犯了一个经典的错误：假设了操作系统对多个进程的调度顺序。考虑这样一种情况，在子进程从管道中读取到<code>&quot;ping&quot;</code>之前，父进程从管道中读取到了自己写入管道的<code>&quot;ping&quot;</code>，这是完全有可能的。</p><p>所以，如果想使用一个管道进行双向通信，还需要引入额外的同步机制，不作深入讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fork())<br>    &#123;<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br>        close(p[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">5</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">5</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>这里需要注意遍历目录结构的时候，需要跳过<code>inum</code>为0的页表项。xv6在删除文件的时候并不删除目录项，而是将目录项的<code>inum</code>标记为0。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FAT32</span>将目录项的第一个字节设置为<span class="hljs-number">0</span>xE5来标记已删除目录项<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>xv6源码阅读：自旋锁的实现</title>
    <link href="/2022/09/05/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/05/xv6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h2><p>基本的实现思路：自旋锁的<code>locked</code>为1时表示该自旋锁被持有，当一个线程试图获得锁时，循环观测<code>locked</code>的值，直到观测到<code>locked</code>的值为0时，说明该锁是空闲的，可以获得锁，把<code>locked</code>的值置为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(l-&gt;locked == <span class="hljs-number">0</span>)&#123;<br>        l-&gt;locked = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑这样一种情况，线程2运行到第二行观测到<code>locked</code>的值为0，在将<code>locked</code>的值设置为1之前，线程2也运行到第2行观测到<code>locked</code>的值为0。此时同时有两个线程可以进入临界区，这不符合自旋锁的基本要求。所以必须保证<code>test-and-set</code>过程（观测和设置<code>locked</code>的值)的原子性。</p><p>xv6中使用了C语言的库函数<code>__sync_lock_test_and_set()</code>原子地执行以下操作：将<code>locked</code>的值置为1，返回<code>locked</code>的旧值。</p><p>分两种情况：如果<code>locked</code>的值为0，这里将<code>locked</code>的值置为1，函数的返回值为0，跳出循环，线程获得了锁；如果<code>locked</code>的值为1，函数返回后<code>locked</code>的值仍为1，继续自旋，无法获得锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    ;<br></code></pre></td></tr></table></figure><h3 id="中断和自旋锁"><a href="#中断和自旋锁" class="headerlink" title="中断和自旋锁"></a>中断和自旋锁</h3><p>一些 xv6 自旋锁保护的数据会被线程和中断处理程序两者使用。正在运行的线程随时可能被中断处理程序打断，在中断处理程序返回之前，线程不会继续运行。如果共享的数据的锁被线程持有，中断处理程序同样想获得锁，必须等待线程释放锁，而线程在中断处理程序返回之前不会释放锁，于是造成了死锁。</p><p>为了避免这种情况，xv6保证一个CPU在持有自旋锁的时候，中断一定是关闭的，在CPU不再持有自旋锁的时候，重新启用中断。</p><p>具体的实现方式：xv6维护了一个Per-CPU state <code>noff</code>，记录CPU持有自旋锁的个数，在<code>acquire()</code>开始时和<code>release()</code>结束时维护<code>noff</code>，在<code>noff</code>降为0时重新开启中断。</p><h3 id="内存序"><a href="#内存序" class="headerlink" title="内存序"></a>内存序</h3><p>CPU和编译器的指令重排可能会把临界区中的代码移出临界区，结果将是灾难性的！为了避免这种情况，我们在自旋锁中加入了内存屏障。内存屏障，顾名思义，就是一堵墙，将墙的前后的指令分隔开，指令重排只能在墙之前的指令之间发生，或者在墙之后的指令之间发生，而无法越过这堵墙。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>理解了获取锁的过程，释放锁就很好理解了，主要步骤如下：设置内存屏障，原子地将<code>locked</code>置为0，处理中断。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来用C++写一个哈希表吧!</title>
    <link href="/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%A7/"/>
    <url>/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>前天写了<a href="http://web.stanford.edu/class/cs106l/">CS106L 2022 SPRING</a>的Assignment3，记录一下自己的收获。</p><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>先分配一个长度和<code>other</code>相同的<code>_buckets_array</code>，然后拷贝<code>other._buckets_array</code>中的每一个链表。需要注意的地方是避免解引用空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(<span class="hljs-type">const</span> HashMap &amp;other) : _size&#123;other._size&#125;,<br>                                                  _hash_function&#123;other._hash_function&#125;,<br>                                                  _buckets_array(other._buckets_array.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">nullptr</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; other._buckets_array.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        node *other_node = other._buckets_array[i];<br>        <span class="hljs-keyword">if</span> (other_node == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _buckets_array[i] = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _buckets_array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(other_node-&gt;value, <span class="hljs-literal">nullptr</span>);<br>            node *curr_node = _buckets_array[i]; <br>            <span class="hljs-keyword">while</span> (other_node-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                other_node = other_node-&gt;next;<br>                curr_node-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(other_node-&gt;value, <span class="hljs-literal">nullptr</span>);<br>                curr_node = curr_node-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">HashMap</span>(HashMap &amp;&amp;other) : _size&#123;other._size&#125;<br>&#123;<br>    _hash_function = std::<span class="hljs-built_in">move</span>(other._hash_function);<br>    _buckets_array = std::<span class="hljs-built_in">move</span>(other._buckets_array);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><p> 首先判断是否是自我赋值，然后调用<code>clear()</code>释放<code>_buckets_array</code>中原有的链表的内存，调用<code>insert()</code>插入新的元素。这里我犯了一个思维定式的错误，盲目把<code>other</code>的所有成员拷贝过来，但是这里<code>_size</code>在<code>insert()</code>和clear&#96;中是自动维护的。</p><p>使用range-based for loop时，如果获取引用而不是值，<code>auto &amp;&amp;value</code>这种写法是最佳实践，这里<code>&amp;&amp;</code>是万能引用，可以自动匹配<code>&amp;</code>,<code>const &amp;</code>或<code>&amp;&amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt; &amp;HashMap&lt;K, M, H&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HashMap&lt;K, M, H&gt; &amp;other)<br>&#123;<br>    <span class="hljs-comment">//比较地址，判断是否是自我赋值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// _size = other._size;</span><br>    _hash_function = other._hash_function;<br>    <span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;&amp;value : other)<br>    &#123;<br>        <span class="hljs-built_in">insert</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动赋值"><a href="#移动赋值" class="headerlink" title="移动赋值"></a>移动赋值</h2><p>同样，首先判断是否是自我赋值，然后move每一个成员。</p><h3 id="边界测试"><a href="#边界测试" class="headerlink" title="边界测试"></a>边界测试</h3><p>这里涉及很多有趣的细节，请教了身边的C++高手，收获颇丰。测试代码中有这样一行，这一行发生了什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map1 = std::<span class="hljs-built_in">move</span>(map2) = std::<span class="hljs-built_in">move</span>(map2) = std::<span class="hljs-built_in">move</span>(map1);<br></code></pre></td></tr></table></figure><p>赋值符号是右结合的，所以先进行的运算是<code>std::move(map2) = std::move(map1)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> <span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">// forward _Arg as movable</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::move(map2)</code>返回了<code>map2</code>的右值引用。对返回值调用<code>=</code>运算符，这时调用了<code>map2</code>的移动赋值函数，我实现的移动赋值函数的返回值是<code>&amp;HashMap</code>类型，所以下一个赋值运算符调用的是拷贝赋值函数！</p><p>还有一个细节，这里在map1移动之后，仍然使用了<code>map1</code>，这不是好的用法，但是C++并没有限制我们这样做。我在<code>gcc version 7.5.0</code>环境下测试，STL中的<code>vector</code>和<code>unordered_map</code>的对象在被移动后，会留下一个空的可以使用的容器。开始我使用移动赋值，把<code>other</code>的<code>_buckets_array</code>的数据转移到了<code>this</code>中，但是这给<code>other</code>留下了一个空的<code>_buckets_array</code>，对于本次设计的<code>HashMap</code>来说，总是假设<code>_buckets_array</code>非空，移动之后的<code>HashMap</code>并不是一个可用的容器。所以这里使用了<code>swap</code>函数实现了<code>_buckets_array</code>的移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br>HashMap&lt;K, M, H&gt; &amp;HashMap&lt;K, M, H&gt;::<span class="hljs-keyword">operator</span>=(HashMap&lt;K, M, H&gt; &amp;&amp;other)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-built_in">clear</span>();<br>    _size = std::<span class="hljs-built_in">move</span>(other._size);<br>    <span class="hljs-comment">//不要混淆_size和_buckets_array.size()</span><br>    other._size = <span class="hljs-number">0</span>;<br>    _hash_function = std::<span class="hljs-built_in">move</span>(other._hash_function);<br>    _buckets_array.<span class="hljs-built_in">swap</span>(other._buckets_array);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const接口的实现"><a href="#const接口的实现" class="headerlink" title="const接口的实现"></a>const接口的实现</h2><p>使用模板生成了<code>iterator</code>和<code>const_iterator</code>两套代码。基础设施写好后，在编写迭代器时，完全不需要考虑返回的是const值还是非const值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst = <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">class</span> HashMapIterator<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> value_type = std::<span class="hljs-type">conditional_t</span>&lt;IsConst, <span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> Map::value_type, <span class="hljs-keyword">typename</span> Map::value_type&gt;;<br><br>    <span class="hljs-keyword">using</span> pointer = value_type *;<br>    <span class="hljs-keyword">using</span> reference = value_type &amp;;<br><br>    reference <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;<br>    pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br>HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-built_in">HashMapIterator</span>(bucket_array_type *buckets_array, node *node,<br>                                               <span class="hljs-type">size_t</span> bucket) : _buckets_array(buckets_array),<br>                                                                _node(node),<br>                                                                _bucket(bucket) &#123;&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::reference HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> _node-&gt;value; <span class="hljs-comment">// _node can&#x27;t be nullptr - that would be dereferencing end()</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Map, <span class="hljs-type">bool</span> IsConst&gt;<br><span class="hljs-keyword">typename</span> HashMapIterator&lt;Map, IsConst&gt;::pointer HashMapIterator&lt;Map, IsConst&gt;::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> &amp;(_node-&gt;value); <span class="hljs-comment">// _node can&#x27;t be nullptr - that would be dereferencing end()</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H = std::hash&lt;K&gt;&gt;<br><span class="hljs-keyword">class</span> HashMap<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> iterator = HashMapIterator&lt;HashMap, <span class="hljs-literal">false</span>&gt;;<br>    <span class="hljs-keyword">using</span> const_iterator = HashMapIterator&lt;HashMap, <span class="hljs-literal">true</span>&gt;;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> K &amp;key)</span> <span class="hljs-type">const</span></span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> K &amp;key)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_iterator</span>(<span class="hljs-built_in">find_node</span>(key).second);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::const_iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> K &amp;key) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-comment">// This is called the static_cast/const_cast trick, which allows us to reuse</span><br>    <span class="hljs-comment">// the non-const version of find to implement the const version.</span><br>    <span class="hljs-comment">// The idea is to cast this so it&#x27;s pointing to a non-const HashMap, which</span><br>    <span class="hljs-comment">// calls the overload above (and prevent infinite recursion).</span><br>    <span class="hljs-comment">// Also note that we are calling the conversion operator in the iterator class!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;const_iterator&gt;(<span class="hljs-keyword">const_cast</span>&lt;HashMap&lt;K, M, H&gt; *&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">find</span>(key));<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> M, <span class="hljs-keyword">typename</span> H&gt;<br><span class="hljs-keyword">typename</span> HashMap&lt;K, M, H&gt;::iterator HashMap&lt;K, M, H&gt;::<span class="hljs-built_in">make_iterator</span>(node *curr)<br>&#123;<br>    <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> &#123;&amp;_buckets_array, curr, <span class="hljs-built_in">bucket_count</span>()&#125;;<br>    &#125;<br>    <span class="hljs-type">size_t</span> index = _hash_function(curr-&gt;value.first) % <span class="hljs-built_in">bucket_count</span>();<br>    <span class="hljs-keyword">return</span> &#123;&amp;_buckets_array, curr, index&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，测试程序存在问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HashMap&lt;std::string, <span class="hljs-type">int</span>&gt; copy = map1;<br>        HashMap&lt;std::string, <span class="hljs-type">int</span>&gt; temp, new_assign;<br>        temp = std::<span class="hljs-built_in">move</span>(map1);<br>        new_assign = std::<span class="hljs-built_in">move</span>(temp);<br>        <span class="hljs-built_in">VERIFY_TRUE</span>(<span class="hljs-built_in">check_map_equal</span>(new_assign, temp), __LINE__);<br></code></pre></td></tr></table></figure><p><code>new_assign</code>和<code>temp</code>是不会<code>equal</code>的，应该把最后一行的<code>temp</code>改为<code>copy</code>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来用C++写一个字典树吧!</title>
    <link href="/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E6%A0%91%E5%90%A7/"/>
    <url>/2022/09/01/%E6%9D%A5%E7%94%A8C-%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E6%A0%91%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>今天写了<a href="https://15445.courses.cs.cmu.edu/fall2022/">CMU15-445 2022 FALL</a>的Project0，记录一下自己的收获。</p><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>这个project的内容是用C++实现一个字典树。字典树需要频繁地对节点的子节点进行查找，插入和删除。unordered_map的底层实现是哈希表，所以查找、插入和删除的平均时间复杂度都是O(1)，在这个project中非常合适。</p><p>我对标准库提供的API还不熟悉，在这里记录一下自己今天的写法,以便日后复习和改正。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//根据指定的key查找对应的value</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-comment">//这里值得注意的是如果key不存在，会自动插入一个默认值，所以先处理了key不存在的情况。</span><br><span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br><br><span class="hljs-comment">//查找unorder_map中是否存在指定的key，和上面的count实现的是相同的功能。</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">find</span>(key_char) != <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-comment">//判断是否为空</span><br><span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">empty</span>();<br><br><span class="hljs-comment">//删除指定的key</span><br><span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">erase</span>(key_char);<br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li>子类想要调用父类的构造函数，只能写在参数初始化列表里面。</li><li>非基本类型尽量在参数列表中赋值，写的时候总是忘记。</li></ol><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>经过实践和思考，我倾向于这样使用<code>unique_ptr</code>：，在想要获得所有权的时候就直接传值，不想要获得所有权的时候直接用<code>get()</code>获取裸指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在插入节点时使用了移动语义</span><br><span class="hljs-comment">//右值引用也许可以避免一次移动构造，但是没有巨大性能差距，可读性不好，语义不清晰</span><br><span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, std::unique_ptr&lt;TrieNode&gt; &amp;&amp;child)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) != <span class="hljs-number">0</span> || child-&gt;<span class="hljs-built_in">GetKeyChar</span>() != key_char) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;children_[key_char] = std::<span class="hljs-built_in">move</span>(child);<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br>matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br><br><span class="hljs-comment">//这里并不会比直接使用get()获得裸指针更安全</span><br><span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="字典树的基本操作实现"><a href="#字典树的基本操作实现" class="headerlink" title="字典树的基本操作实现"></a>字典树的基本操作实现</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>遍历key，如果当前节点的子节点中没有key[i]，则插入一个新的节点，否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点的is_end_为true,则插入失败；否则插入成功，将当前节点的is_end_置为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, T value)</span> </span>&#123;<br>    <span class="hljs-function">LatchWriteGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;latch_)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]) == <span class="hljs-literal">nullptr</span>) &#123;<br>        matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br>      &#125;<br>      <span class="hljs-keyword">auto</span> father_node = matched_node;<br>      matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里调用了TrieNodeWithValue的移动构造函数，将原来不含value的节点转换成了一个含有value的节点</span><br>        <span class="hljs-comment">//然后使用新节点替换了原来的节点</span><br>        <span class="hljs-keyword">auto</span> new_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(std::<span class="hljs-built_in">move</span>(**matched_node), value);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key[i]);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">move</span>(new_node));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>遍历key，使用一个栈保存遍历的路径。如果当前节点的子节点中没有key[i]，则删除失败；否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点的is_end_为false,则删除失败；否则删除成功，把is_end置为true。如果这个节点有子节点，删除结束。如果这个节点没有子节点，需要删除这个节点。然后回溯栈，删除没有子节点且没有值得节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>  <span class="hljs-function">LatchWriteGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;latch_)</span></span>;<br>  <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">auto</span> node_stack = std::stack&lt;std::unique_ptr&lt;TrieNode&gt; *&gt;();<br>  <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>    <span class="hljs-type">char</span> key_char = key[i];<br>    <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    node_stack.<span class="hljs-built_in">push</span>(matched_node);<br>    matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char);<br>    <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">SetEndNode</span>(<span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key_char);<br>      <span class="hljs-keyword">while</span> (node_stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">auto</span> node = node_stack.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>() || node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        node_stack.<span class="hljs-built_in">pop</span>();<br>        node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetKeyChar</span>());<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>遍历key，如果当前节点的子节点中没有key[i]，查找失败，否则继续遍历下一个字符。遍历到最后一个字符，如果当前节点没有值或者值的类型和查找的值的类型不匹配，查找失败，否则查找成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">bool</span> *success)</span> </span>&#123;<br>    <span class="hljs-function">LatchWriteGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;latch_)</span></span>;<br>    <span class="hljs-keyword">auto</span> cur_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-type">char</span> cur_char = key[i];<br>      <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      cur_node = cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-comment">//使用dynamic_cast检查节点含有的值的类型和要查找的值的类型是否相同。</span><br>          <span class="hljs-keyword">auto</span> tmp_node = <span class="hljs-keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur_node-&gt;<span class="hljs-built_in">get</span>());<br>          <span class="hljs-keyword">if</span> (tmp_node != <span class="hljs-literal">nullptr</span>) &#123;<br>            *success = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> tmp_node-&gt;<span class="hljs-built_in">GetValue</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    *success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>定义了两个锁资源管理类管理读写锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LatchWriteGuard</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LatchWriteGuard</span><span class="hljs-params">(ReaderWriterLatch *latch)</span> : latch_(latch) &#123;</span> latch_-&gt;<span class="hljs-built_in">WLock</span>(); &#125;<br>  ~<span class="hljs-built_in">LatchWriteGuard</span>() &#123; latch_-&gt;<span class="hljs-built_in">WUnlock</span>(); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ReaderWriterLatch *latch_;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LatchReadGuard</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LatchReadGuard</span><span class="hljs-params">(ReaderWriterLatch *latch)</span> : latch_(latch) &#123;</span> latch_-&gt;<span class="hljs-built_in">RLock</span>(); &#125;<br>  ~<span class="hljs-built_in">LatchReadGuard</span>() &#123; latch_-&gt;<span class="hljs-built_in">RUnlock</span>(); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ReaderWriterLatch *latch_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//===----------------------------------------------------------------------===//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                         BusTub</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// p0_trie.h</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Identification: src/include/primer/p0_trie.h</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Copyright (c) 2015-2022, Carnegie Mellon University Database Group</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//===----------------------------------------------------------------------===//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common/exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;common/rwlatch.h&quot;</span></span><br><span class="hljs-keyword">namespace</span> bustub &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LatchWriteGuard</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LatchWriteGuard</span><span class="hljs-params">(ReaderWriterLatch *latch)</span> : latch_(latch) &#123;</span> latch_-&gt;<span class="hljs-built_in">WLock</span>(); &#125;<br>  ~<span class="hljs-built_in">LatchWriteGuard</span>() &#123; latch_-&gt;<span class="hljs-built_in">WUnlock</span>(); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ReaderWriterLatch *latch_;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LatchReadGuard</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LatchReadGuard</span><span class="hljs-params">(ReaderWriterLatch *latch)</span> : latch_(latch) &#123;</span> latch_-&gt;<span class="hljs-built_in">RLock</span>(); &#125;<br>  ~<span class="hljs-built_in">LatchReadGuard</span>() &#123; latch_-&gt;<span class="hljs-built_in">RUnlock</span>(); &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  ReaderWriterLatch *latch_;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TrieNode is a generic container for any node in Trie.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Construct a new Trie Node object with the given key char.</span><br><span class="hljs-comment">   * is_end_ flag should be initialized to false in this constructor.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key_char Key character of this trie node</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> : key_char_(key_char) &#123;</span>&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Move constructor for trie node object. The unique pointers stored</span><br><span class="hljs-comment">   * in children_ should be moved from other_trie_node to new trie node.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param other_trie_node Old trie node.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">TrieNode</span>(TrieNode &amp;&amp;other_trie_node) <span class="hljs-keyword">noexcept</span><br>      : <span class="hljs-built_in">key_char_</span>(other_trie_node.key_char_),<br>        <span class="hljs-built_in">is_end_</span>(other_trie_node.is_end_),<br>        <span class="hljs-built_in">children_</span>(std::<span class="hljs-built_in">move</span>(other_trie_node.children_)) &#123;&#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @brief Destroy the TrieNode object.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TrieNode</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Whether this trie node has a child node with specified key char.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key_char Key char of child node.</span><br><span class="hljs-comment">   * @return True if this trie node has a child with given key, false otherwise.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">HasChild</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span>  <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">find</span>(key_char) != <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">end</span>(); &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Whether this trie node has any children at all. This is useful</span><br><span class="hljs-comment">   * when implementing &#x27;Remove&#x27; functionality.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @return True if this trie node has any child node, false if it has no child node.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">HasChildren</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">empty</span>(); &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Whether this trie node is the ending character of a key string.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @return True if is_end_ flag is true, false if is_end_ is false.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">IsEndNode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;is_end_; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Return key char of this trie node.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @return key_char_ of this trie node.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">GetKeyChar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> key_char_; &#125;<br><br>  std::unordered_map&lt;<span class="hljs-type">char</span>, std::unique_ptr&lt;TrieNode&gt;&gt; &amp;<span class="hljs-built_in">GetChildren</span>() &#123; <span class="hljs-keyword">return</span> children_; &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Insert a child node for this trie node into children_ map, given the key char and</span><br><span class="hljs-comment">   * unique_ptr of the child node. If specified key_char already exists in children_,</span><br><span class="hljs-comment">   * return nullptr. If parameter `child`&#x27;s key char is different than parameter</span><br><span class="hljs-comment">   * `key_char`, return nullptr.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * Note that parameter `child` is rvalue and should be moved when it is</span><br><span class="hljs-comment">   * inserted into children_map.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * The return value is a pointer to unique_ptr because pointer to unique_ptr can access the</span><br><span class="hljs-comment">   * underlying data without taking ownership of the unique_ptr. Further, we can set the return</span><br><span class="hljs-comment">   * value to nullptr when error occurs.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key Key of child node</span><br><span class="hljs-comment">   * @param child Unique pointer created for the child node. This should be added to children_ map.</span><br><span class="hljs-comment">   * @return Pointer to unique_ptr of the inserted child node. If insertion fails, return nullptr.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, std::unique_ptr&lt;TrieNode&gt; child)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) != <span class="hljs-number">0</span> || child-&gt;<span class="hljs-built_in">GetKeyChar</span>() != key_char) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;children_[key_char] = std::<span class="hljs-built_in">move</span>(child);<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Get the child node given its key char. If child node for given key char does</span><br><span class="hljs-comment">   * not exist, return nullptr.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key Key of child node</span><br><span class="hljs-comment">   * @return Pointer to unique_ptr of the child node, nullptr if child</span><br><span class="hljs-comment">   *         node does not exist.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">std::unique_ptr&lt;TrieNode&gt; *<span class="hljs-title">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-keyword">this</span>-&gt;children_[key_char];<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Remove child node from children_ map.</span><br><span class="hljs-comment">   * If key_char does not exist in children_, return immediately.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key_char Key char of child node to be removed</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RemoveChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">count</span>(key_char) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>-&gt;children_.<span class="hljs-built_in">erase</span>(key_char);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Set the is_end_ flag to true or false.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param is_end Whether this trie node is ending char of a key string</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEndNode</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_end)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;is_end_ = is_end; &#125;<br><br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">/** Key character of this trie node */</span><br>  <span class="hljs-type">char</span> key_char_;<br>  <span class="hljs-comment">/** whether this node marks the end of a key */</span><br>  <span class="hljs-type">bool</span> is_end_&#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-comment">/** A map of all child nodes of this trie node, which can be accessed by each</span><br><span class="hljs-comment">   * child node&#x27;s key char. */</span><br>  std::unordered_map&lt;<span class="hljs-type">char</span>, std::unique_ptr&lt;TrieNode&gt;&gt; children_;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * TrieNodeWithValue is a node that mark the ending of a key, and it can</span><br><span class="hljs-comment"> * hold a value of any type T.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNodeWithValue</span> : <span class="hljs-keyword">public</span> TrieNode &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* Value held by this trie node. */</span><br>  T value_;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Construct a new TrieNodeWithValue object from a TrieNode object and specify its value.</span><br><span class="hljs-comment">   * This is used when a non-terminal TrieNode is converted to terminal TrieNodeWithValue.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * The children_ map of TrieNode should be moved to the new TrieNodeWithValue object.</span><br><span class="hljs-comment">   * Since it contains unique pointers, the first parameter is a rvalue reference.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * You should:</span><br><span class="hljs-comment">   * 1) invoke TrieNode&#x27;s move constructor to move data from TrieNode to</span><br><span class="hljs-comment">   * TrieNodeWithValue.</span><br><span class="hljs-comment">   * 2) set value_ member variable of this node to parameter `value`.</span><br><span class="hljs-comment">   * 3) set is_end_ to true</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param trieNode TrieNode whose data is to be moved to TrieNodeWithValue</span><br><span class="hljs-comment">   * @param value</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">TrieNodeWithValue</span>(TrieNode &amp;&amp;trieNode, T value) : <span class="hljs-built_in">TrieNode</span>(std::<span class="hljs-built_in">move</span>(trieNode)) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;value_ = value;<br>    <span class="hljs-keyword">this</span>-&gt;is_end_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Construct a new TrieNodeWithValue. This is used when a new terminal node is constructed.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * You should:</span><br><span class="hljs-comment">   * 1) Invoke the constructor for TrieNode with given key_char.</span><br><span class="hljs-comment">   * 2) Set value_ for this node.</span><br><span class="hljs-comment">   * 3) set is_end_ to true.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key_char Key char of this node</span><br><span class="hljs-comment">   * @param value Value of this node</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">TrieNodeWithValue</span>(<span class="hljs-type">char</span> key_char, T value) : <span class="hljs-built_in">TrieNode</span>(key_char) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;value_ = value;<br>    <span class="hljs-keyword">this</span>-&gt;is_end_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @brief Destroy the Trie Node With Value object</span><br><span class="hljs-comment">   */</span><br>  ~<span class="hljs-built_in">TrieNodeWithValue</span>() <span class="hljs-keyword">override</span> = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @brief Get the stored value_.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @return Value of type T stored in this node</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Trie is a concurrent key-value store. Each key is string and its corresponding</span><br><span class="hljs-comment"> * value can be any type.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/* Root node of the trie */</span><br>  std::unique_ptr&lt;TrieNode&gt; root_;<br>  <span class="hljs-comment">/* Read-write lock for the trie */</span><br>  ReaderWriterLatch latch_;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Construct a new Trie object. Initialize the root node with &#x27;\0&#x27;</span><br><span class="hljs-comment">   * character.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-built_in">Trie</span>() &#123; <span class="hljs-keyword">this</span>-&gt;root_ = std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(<span class="hljs-string">&#x27;\0&#x27;</span>); &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Insert key-value pair into the trie.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * If key is empty string, return false immediately.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * If key already exists, return false. Duplicated keys are not allowed and</span><br><span class="hljs-comment">   * you should never overwrite value of an existing key.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * When you reach the ending character of a key:</span><br><span class="hljs-comment">   * 1. If TrieNode with this ending character does not exist, create new TrieNodeWithValue</span><br><span class="hljs-comment">   * and add it to parent node&#x27;s children_ map.</span><br><span class="hljs-comment">   * 2. If the terminal node is a TrieNode, then convert it into TrieNodeWithValue by</span><br><span class="hljs-comment">   * invoking the appropriate constructor.</span><br><span class="hljs-comment">   * 3. If it is already a TrieNodeWithValue,</span><br><span class="hljs-comment">   * then insertion fails and return false. Do not overwrite existing data with new data.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * You can quickly check whether a TrieNode pointer holds TrieNode or TrieNodeWithValue</span><br><span class="hljs-comment">   * by checking the is_end_ flag. If is_end_ == false, then it points to TrieNode. If</span><br><span class="hljs-comment">   * is_end_ == true, it points to TrieNodeWithValue.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key Key used to traverse the trie and find correct node</span><br><span class="hljs-comment">   * @param value Value to be inserted</span><br><span class="hljs-comment">   * @return True if insertion succeeds, false if key already exists</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, T value)</span> </span>&#123;<br>    <span class="hljs-function">LatchWriteGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;latch_)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]) == <span class="hljs-literal">nullptr</span>) &#123;<br>        matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">make_unique</span>&lt;TrieNode&gt;(key[i]));<br>      &#125;<br>      <span class="hljs-keyword">auto</span> father_node = matched_node;<br>      matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key[i]);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> new_node = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(std::<span class="hljs-built_in">move</span>(**matched_node), value);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key[i]);<br>        father_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">InsertChildNode</span>(key[i], std::<span class="hljs-built_in">move</span>(new_node));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Remove key value pair from the trie.</span><br><span class="hljs-comment">   * This function should also remove nodes that are no longer part of another</span><br><span class="hljs-comment">   * key. If key is empty or not found, return false.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * You should:</span><br><span class="hljs-comment">   * 1) Find the terminal node for the given key.</span><br><span class="hljs-comment">   * 2) If this terminal node does not have any children, remove it from its</span><br><span class="hljs-comment">   * parent&#x27;s children_ map.</span><br><span class="hljs-comment">   * 3) Recursively remove nodes that have no children and is not terminal node</span><br><span class="hljs-comment">   * of another key.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key Key used to traverse the trie and find correct node</span><br><span class="hljs-comment">   * @return True if key exists and is removed, false otherwise</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span> </span>&#123;<br>    <span class="hljs-function">LatchWriteGuard <span class="hljs-title">guard</span><span class="hljs-params">(&amp;latch_)</span></span>;<br>    <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> node_stack = std::stack&lt;std::unique_ptr&lt;TrieNode&gt; *&gt;();<br>    <span class="hljs-keyword">auto</span> matched_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-type">char</span> key_char = key[i];<br>      <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      node_stack.<span class="hljs-built_in">push</span>(matched_node);<br>      matched_node = matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(key_char);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">SetEndNode</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (matched_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(key_char);<br>        <span class="hljs-keyword">while</span> (node_stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">auto</span> node = node_stack.<span class="hljs-built_in">top</span>();<br>          <span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">HasChildren</span>() || node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          node_stack.<span class="hljs-built_in">pop</span>();<br>          node_stack.<span class="hljs-built_in">top</span>()-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">RemoveChildNode</span>(node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetKeyChar</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * TODO(P0): Add implementation</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @brief Get the corresponding value of type T given its key.</span><br><span class="hljs-comment">   * If key is empty, set success to false.</span><br><span class="hljs-comment">   * If key does not exist in trie, set success to false.</span><br><span class="hljs-comment">   * If given type T is not the same as the value type stored in TrieNodeWithValue</span><br><span class="hljs-comment">   * (ie. GetValue&lt;int&gt; is called but terminal node holds std::string),</span><br><span class="hljs-comment">   * set success to false.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * To check whether the two types are the same, dynamic_cast</span><br><span class="hljs-comment">   * the terminal TrieNode to TrieNodeWithValue&lt;T&gt;. If the casted result</span><br><span class="hljs-comment">   * is not nullptr, then type T is the correct type.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @param key Key used to traverse the trie and find correct node</span><br><span class="hljs-comment">   * @param success Whether GetValue is successful or not</span><br><span class="hljs-comment">   * @return Value of type T if type matches</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-function">T <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key, <span class="hljs-type">bool</span> *success)</span> </span>&#123;<br>    latch_.<span class="hljs-built_in">RLock</span>();<br>    <span class="hljs-keyword">auto</span> cur_node = &amp;<span class="hljs-keyword">this</span>-&gt;root_;<br>    <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; key_size; i++) &#123;<br>      <span class="hljs-type">char</span> cur_char = key[i];<br>      <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char) == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      cur_node = cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">GetChildNode</span>(cur_char);<br>      <span class="hljs-keyword">if</span> (i == key_size - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur_node-&gt;<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">IsEndNode</span>()) &#123;<br>          <span class="hljs-keyword">auto</span> tmp_node = <span class="hljs-keyword">dynamic_cast</span>&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur_node-&gt;<span class="hljs-built_in">get</span>());<br>          <span class="hljs-keyword">if</span> (tmp_node != <span class="hljs-literal">nullptr</span>) &#123;<br>            *success = <span class="hljs-literal">true</span>;<br>            latch_.<span class="hljs-built_in">RUnlock</span>();<br>            <span class="hljs-keyword">return</span> tmp_node-&gt;<span class="hljs-built_in">GetValue</span>();<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    *success = <span class="hljs-literal">false</span>;<br>    latch_.<span class="hljs-built_in">RUnlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>();<br>  &#125;<br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace bustub</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
